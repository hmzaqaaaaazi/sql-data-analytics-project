--- Advanced Data Analytics

--1) Sales performance over time (Trend yearly)

SELECT
EXTRACT(YEAR FROM order_date) AS order_year,
SUM(sales_amount) AS total_sales,
COUNT(DISTINCT(customer_key)) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY order_year
ORDER BY order_year;

--1.1) Sales performance over time (Trend monthly also seasonality)

SELECT
EXTRACT(MONTH FROM order_date) AS order_month,
SUM(sales_amount) AS total_sales,
COUNT(DISTINCT(customer_key)) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY order_month
ORDER BY order_month;

--1.2) (yearly and monthly)

SELECT
EXTRACT(YEAR FROM order_date) AS order_year,
EXTRACT(MONTH FROM order_date) AS order_month,
SUM(sales_amount) AS total_sales,
COUNT(DISTINCT(customer_key)) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY order_year, order_month
ORDER BY order_year,order_month;

-- using trunc

SELECT
DATE_TRUNC('MONTH', order_date) AS order_date,
SUM(sales_amount) AS total_sales,
COUNT(DISTINCT(customer_key)) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATE_TRUNC('MONTH', order_date)
ORDER BY order_date;

---2) Cummulative Analysis

-- Calculate the total sales per month
-- and the running total of sales over time



SELECT
order_date,
total_sales,
SUM(total_sales) OVER(ORDER BY order_date) AS running_total_sales
FROM (
SELECT
DATE_TRUNC('MONTH', order_date) AS order_date,
SUM(sales_amount) AS total_sales
FROM
gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATE_TRUNC('MONTH', order_date)
);

-- MOVING AVERAGE 

SELECT
order_date,
total_sales,
AVG(total_sales) OVER(ORDER BY order_date) AS moving_average_sales
FROM (
SELECT
DATE_TRUNC('MONTH', order_date) AS order_date,
SUM(sales_amount) AS total_sales
FROM
gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATE_TRUNC('MONTH', order_date)
);

-- TO_CHAR()
SELECT
    TO_CHAR(order_date, 'YYYY-MM') AS order_month,
    SUM(sales_amount) AS total_sales
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY TO_CHAR(order_date, 'YYYY-MM')
ORDER BY order_month;

--- 3) Performance Analysis
/* Analyze the yearly performane of the products by comparing their sales
to both the average sales performance of the product and the previous year sales */

WITH yearly_product_sales AS (
SELECT
    EXTRACT(YEAR FROM f.order_date) AS order_year,
    p.product_name,
    SUM(f.sales_amount) AS current_sales
FROM gold.fact_sales AS f
LEFT JOIN gold.dim_products AS p
ON f.product_key = p.product_key
WHERE order_date IS NOT NULL
GROUP BY
EXTRACT(YEAR FROM f.order_date),
p.product_name
)
SELECT
order_year,
product_name,
current_sales,
AVG(current_sales) OVER(PARTITION BY product_name) AS avg_sales,
current_sales - AVG(current_sales) OVER(PARTITION BY product_name) AS diff_avg,
CASE WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) > 0 THEN 'Above_avg'
     WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) < 0 THEN 'below_avg'
     ELSE 'Avg'
END AS change_avg,
LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS py_sales,
current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS diff_py,
CASE WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) > 0 THEN 'increasing'
     WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) < 0 THEN 'decreasing'
     ELSE 'no change'
END AS py_change
FROM yearly_product_sales
ORDER BY product_name, order_year;

--- 4) Part to whole Analysis

-- Which categories contribute the most to overall sales?

WITH category_sales AS (
SELECT
    category,
    SUM(sales_amount) AS total_sales
FROM gold.fact_sales AS f
LEFT JOIN gold.dim_products AS p
ON f.product_key = p.product_key
GROUP BY category
)

SELECT
category,
total_sales,
SUM(total_sales) OVER () AS overall_sales,
CONCAT(ROUND((total_sales / SUM(total_sales) OVER ()) * 100,2), ' %') AS percentage_of_total
FROM category_sales
ORDER BY total_sales DESC;

---5) Data Segmentation

/*Segment products into cost ranges and
 count how many products fall into each segment */

WITH product_segments AS (
SELECT
product_key,
product_name,
cost,
CASE WHEN cost < 100 THEN 'Below 100'
     WHEN cost BETWEEN 100 AND 500 THEN '100-500'
     WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
     ELSE 'Above 1000'
END AS cost_range
FROM gold.dim_products
)
SELECT
cost_range,
COUNT(product_key) AS total_products
FROM product_segments
GROUP BY cost_range
ORDER BY total_products DESC:


/* Group customers into three segments based on their spending behaviour:
  - VIP: Customers with atleast 12 months of history but spending more than 5000.
  - Regular: Customers with atleast 12 months of history but spending 5000 or less.
  - New: Customers with a lifespan of less than 12 months.
Find the total number of customers by each group.
*/

WITH customer_spending AS (
SELECT
    c.customer_key,
    SUM(f.sales_amount) AS total_spending,
    MIN(f.order_date) AS first_order,
    MAX(f.order_date) AS last_order,
-- Days active
    MAX(f.order_date) - MIN(f.order_date) AS lifespan_days,
    -- Years active  
    EXTRACT(YEAR FROM AGE(MAX(f.order_date), MIN(f.order_date))) AS lifespan_years,
    -- Total months active (more accurate)
    EXTRACT(YEAR FROM AGE(MAX(f.order_date), MIN(f.order_date))) * 12 + 
    EXTRACT(MONTH FROM AGE(MAX(f.order_date), MIN(f.order_date))) AS lifespan_months
FROM gold.fact_sales AS f
LEFT JOIN gold.dim_customers c
ON f.customer_key = c.customer_key
GROUP BY c.customer_key
ORDER BY total_spending DESC
)

SELECT
customer_segment,
COUNT(customer_key) AS total_customers
FROM (
SELECT
customer_key,
CASE WHEN lifespan_months > 12 AND total_spending > 5000 THEN 'VIP'
     WHEN lifespan_months > 12 AND total_spending <= 5000 THEN 'Regular'
     ELSE 'New customer'
END AS customer_segment
FROM customer_spending)
GROUP BY customer_segment
ORDER BY total_customers;

--- 6) Reports

--1) Base Query: retreive core columns from the tables.
DROP VIEW IF EXISTS gold.report_customers;
CREATE VIEW gold.report_customers AS

WITH base_query AS (
SELECT
f.order_number,
f.product_key,
f.order_date,
f.sales_amount,
f.quantity,
c.customer_key,
c.customer_number,
CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.birthdate)) AS age
FROM gold.fact_sales AS f
LEFT JOIN gold.dim_customers AS c
ON f.customer_key = c.customer_key
WHERE order_date IS NOT NULL
),
customer_aggregation AS (
SELECT
    customer_key,
    customer_number,
    customer_name,
    age,
    COUNT(DISTINCT(order_number)) AS total_orders,
    SUM(sales_amount) AS total_sales,
    SUM(quantity) AS total_quantity,
    COUNT(DISTINCT(product_key)) AS total_products,
    MAX(order_date) AS last_order,
    EXTRACT(YEAR FROM AGE(MAX(order_date), MIN(order_date))) * 12 + 
    EXTRACT(MONTH FROM AGE(MAX(order_date), MIN(order_date))) AS lifespan_months
FROM base_query
GROUP BY 
    customer_key,
    customer_number,
    customer_name,
    age
)

SELECT
    customer_key,
    customer_number,
    customer_name,
    age,
    CASE WHEN age < 20 THEN 'Under 20'
        WHEN age BETWEEN 20 AND 29 THEN '20-29'
        WHEN age BETWEEN 30 AND 39 THEN '30-39'
        WHEN age BETWEEN 40 AND 49 THEN '40-49'
        ELSE 'Above 50'
END AS age_group,
    CASE WHEN lifespan_months >= 12 AND total_sales > 5000 THEN 'VIP'
         WHEN lifespan_months >= 12 AND total_sales <= 5000 THEN 'Regular'
         ELSE 'New customer'
END AS customer_segment,
    last_order,
    EXTRACT(MONTH FROM AGE(CURRENT_DATE, last_order)) AS recency,
    total_orders,
    total_sales,
    total_quantity,
    total_products,
    lifespan_months,
    -- Compuate average order value (AVO)
    CASE WHEN total_sales = 0 THEN 0
	ELSE total_sales / total_orders
END AS avg_order_value,
-- Compuate average monthly spend
    CASE WHEN lifespan_months = 0 THEN total_sales
    ELSE total_sales / lifespan_months
END AS avg_monthly_spend
FROM customer_aggregation;



DROP VIEW IF EXISTS gold.report_products;

-- Create the view
CREATE VIEW gold.report_products AS
WITH base_query AS (
/*---------------------------------------------------------------------------
1) Base Query: Retrieves core columns from fact_sales and dim_products
---------------------------------------------------------------------------*/
    SELECT
        f.order_number,
        f.order_date,
        f.customer_key,
        f.sales_amount,
        f.quantity,
        p.product_key,
        p.product_name,
        p.category,
        p.sub_category AS subcategory,
        p.cost
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON f.product_key = p.product_key
    WHERE f.order_date IS NOT NULL  -- only consider valid sales dates
),
product_aggregations AS (
/*---------------------------------------------------------------------------
2) Product Aggregations: Summarizes key metrics at the product level
---------------------------------------------------------------------------*/
    SELECT
        product_key,
        product_name,
        category,
        subcategory,
        cost,
        -- PostgreSQL: Calculate lifespan in months
        EXTRACT(YEAR FROM AGE(MAX(order_date), MIN(order_date))) * 12 + 
        EXTRACT(MONTH FROM AGE(MAX(order_date), MIN(order_date))) AS lifespan,
        MAX(order_date) AS last_sale_date,
        COUNT(DISTINCT order_number) AS total_orders,
        COUNT(DISTINCT customer_key) AS total_customers,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        -- PostgreSQL: Average selling price calculation
        ROUND(AVG(sales_amount / NULLIF(quantity, 0)), 1) AS avg_selling_price
    FROM base_query
    GROUP BY
        product_key,
        product_name,
        category,
        subcategory,
        cost
)
/*---------------------------------------------------------------------------
  3) Final Query: Combines all product results into one output
---------------------------------------------------------------------------*/
SELECT 
    product_key,
    product_name,
    category,
    subcategory,
    cost,
    last_sale_date,
    -- PostgreSQL: Recency calculation using AGE
    EXTRACT(YEAR FROM AGE(CURRENT_DATE, last_sale_date)) * 12 + 
    EXTRACT(MONTH FROM AGE(CURRENT_DATE, last_sale_date)) AS recency_in_months,
    CASE
        WHEN total_sales > 50000 THEN 'High-Performer'
        WHEN total_sales >= 10000 THEN 'Mid-Range'
        ELSE 'Low-Performer'
    END AS product_segment,
    lifespan,
    total_orders,
    total_sales,
    total_quantity,
    total_customers,
    avg_selling_price,
    -- Average Order Revenue (AOR)
    CASE 
        WHEN total_orders = 0 THEN 0
        ELSE ROUND(total_sales / total_orders, 2)
    END AS avg_order_revenue,
    -- Average Monthly Revenue
    CASE
        WHEN lifespan = 0 THEN total_sales
        ELSE ROUND(total_sales / lifespan, 2)
    END AS avg_monthly_revenue
FROM product_aggregations 
ORDER BY total_sales DESC;
